import torch
import torch.nn as nn
import torch.optim as optim
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from torch.utils.data import DataLoader, TensorDataset

# 1. å¼ºåˆ¶å¯ç”¨ GPU åŠ é€Ÿ
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"ğŸš€ æ­£åœ¨ä½¿ç”¨è®¾å¤‡: {device}")

# 2. åŠ è½½æ•°æ®
data = pd.read_csv('hand_data.csv')
X = data.iloc[:, 1:].values.astype(np.float32)  # 63ä¸ªåæ ‡ (x,y,z)
y = data.iloc[:, 0].values.astype(np.int64)  # æ ‡ç­¾ (0,1,2)

# åˆ’åˆ†è®­ç»ƒé›†(80%)å’Œæµ‹è¯•é›†(20%)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# è½¬ä¸º PyTorch å¼ é‡å¹¶æ¬è¿åˆ° GPU
X_train = torch.FloatTensor(X_train).to(device)
y_train = torch.LongTensor(y_train).to(device)
X_test = torch.FloatTensor(X_test).to(device)
y_test = torch.LongTensor(y_test).to(device)

# å°è£…æ•°æ®åŠ è½½å™¨ (æ¯æ‰¹è®­ç»ƒ16ç»„æ•°æ®)
train_loader = DataLoader(TensorDataset(X_train, y_train), batch_size=16, shuffle=True)


# 3. å®šä¹‰ TinyML ç¥ç»ç½‘ç»œæ¶æ„ (ä¸º ESP32 ä¼˜åŒ–)
class TinyHandModel(nn.Module):
    def __init__(self):
        super(TinyHandModel, self).__init__()
        self.fc1 = nn.Linear(63, 32)  # è¾“å…¥å±‚
        self.fc2 = nn.Linear(32, 16)  # éšè—å±‚
        self.fc3 = nn.Linear(16, 3)  # è¾“å‡ºå±‚ (çŸ³å¤´, å‰ªåˆ€, å¸ƒ)
        self.relu = nn.ReLU()

    def forward(self, x):
        x = self.relu(self.fc1(x))
        x = self.relu(self.fc2(x))
        x = self.fc3(x)
        return x


model = TinyHandModel().to(device)

# 4. å®šä¹‰æŸå¤±å‡½æ•°å’Œä¼˜åŒ–å™¨
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# 5. å¼€å§‹å¾ªç¯è®­ç»ƒ
print("å¼€å§‹åœ¨ GPU ä¸Šç‚¼ä¸¹...")
epochs = 100
for epoch in range(epochs):
    model.train()
    for inputs, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

    # æ¯ 10 è½®è¾“å‡ºä¸€æ¬¡å‡†ç¡®ç‡
    if (epoch + 1) % 10 == 0:
        model.eval()
        with torch.no_grad():
            test_outputs = model(X_test)
            _, predicted = torch.max(test_outputs, 1)
            accuracy = (predicted == y_test).sum().item() / y_test.size(0)
            print(f"è½®æ¬¡ [{epoch + 1}/{epochs}], æŸå¤±: {loss.item():.4f}, æµ‹è¯•é›†å‡†ç¡®ç‡: {accuracy * 100:.2f}%")

# 6. ä¿å­˜è®­ç»ƒå¥½çš„æˆæœ
torch.save(model.state_dict(), "hand_model.pth")
print("\nğŸ‰ è®­ç»ƒå®Œæˆï¼æ¨¡å‹å·²ä¿å­˜ä¸º: hand_model.pth")
